* Phase mismatch is now detected in signatures (i.e. the compiler will complain if you try to match a `static val` and a `val`).
* We are now focusing on quoting and splicing. The splicing part involved quite a lot of refactoring in `Translstatic`: `Translstatic` used to translate an implementation file into a lambda creating the module and adding a reference to it in the symtable. Now the lambda generated by `Translstatic` not only creates the module but also returns an array of untyped ASTs, corresponding to all the splicings of code into phase zero (i.e. splicings that are not inside a quotation).
* In a new module `Runstatic`, this static lambda code is run and the splicings are actually reified. They are then used by `Translcore` to "fill" phase-zero splicings every time it encounters one. This approach is implemented and compiles, but not yet thoroughly tested, since to test splicing something has to be quoted, and the quoting library is not integrated into the compiler yet.
* Finally, I started working on integrating the quoting library written by Leo White. The main function `Translquote.quote_expression`, takes a typed tree and returns the lambda code that will generate the isomorphic *untyped* tree at run-time (well, at static run-time). This work is still going on.

Limitations:  
* As stated above splicing is untested for now.
* Because I didn't know whether I should reimplement some parts of `Translmod` in `Translstatic`, module coercions are still not handled by `Translstatic`. So for now, coercing static components of a `.ml` using a `.mli` won't work — the fix is easy but I'm focusing on quoting for now.

